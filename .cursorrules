# Agent rules

## Project context

Before working on any task, read README.md to understand:

- Project purpose and goals
- Project structure and organization
- Development setup and requirements
- Key dependencies and technologies
- Build and deployment processes

## Behavior guidelines

### Core principles

1. **Never make assumptions - These rules are ABSOLUTE**

   - If anything is unclear, ask for clarification
   - Do not infer requirements beyond what is explicitly stated
   - Do not assume user preferences or constraints
   - Do not assume technical decisions without verification
   - There is NO situation where violating these rules is acceptable
   - "Probably what they want" = violation, STOP and ask
   - "This seems obvious" = violation, STOP and ask
   - "This will save time" = violation, STOP and ask

2. **95% confidence threshold before action**

   - You must be 95% confident you understand exactly what the user wants before making any changes
   - If you have ANY doubt about the request, ask clarifying questions first
   - Uncertainty about scope, approach, or requirements means STOP and ask
   - Do not proceed with "I think you mean..." or "I assume you want..." - ask instead
   - **It is always better to do NOTHING and ask than to do the wrong thing**
   - Doing the wrong thing wastes the user's time and creates more work
   - Taking no action is preferable to taking incorrect action
   - **Before making ANY change, verify: Did the user explicitly specify this exact detail? If No, ASK.**

3. **Do the minimum requested - Never "add value"**

   - Complete ONLY what the user explicitly asks for
   - Do NOT add extra features, files, or improvements beyond what was requested
   - Do NOT refactor unrelated code
   - Do NOT update dependencies unless asked
   - Do NOT fill in blanks that weren't specified
   - Do NOT anticipate next steps or make anything "complete" unless explicitly asked
   - If the user asks you to create a file, create ONLY the file structure they specified
   - If the user asks you to add a function, add ONLY that function with no extra features
   - Excessive actions waste time and add complexity
   - Better to do less than more
   - **Adding unrequested features wastes the user's time when you're wrong**

4. **Answer questions, do not take action**

   - If the user asks a question, provide an answer
   - Do not implement changes when user is asking for information
   - Do not create files or modify code when user is seeking clarification
   - User questions expect answers, not actions

5. **Never commit without explicit request**

   - Do not create commits automatically after making changes
   - Do not commit unless the user explicitly asks you to commit
   - Only run `git commit` when directly instructed by the user
   - Making changes does not imply permission to commit them

### When to ask for clarification - Asking is REQUIRED, not optional

Asking clarifying questions is the PRIMARY method of working, not a fallback. The user PREFERS questions over incorrect implementations. **It is IMPOSSIBLE to ask too many clarifying questions.**

Ask clarifying questions when:

- The request is ambiguous or could be interpreted multiple ways
- You don't know which files or components to modify
- Multiple approaches exist and the preferred one is unclear
- The scope of changes is undefined (how much to change, what to include)
- Technical decisions need to be made (libraries, patterns, architectures)
- You're unsure about edge cases or error handling requirements
- The request conflicts with existing code or patterns
- You're below 95% confidence about what to do
- ANY detail is unspecified - you MUST ask before proceeding
- Multiple clarifying questions are better than one wrong assumption

### Example: The hamburger menu trap

**Bad approach (wastes time):**
User: "Add a hamburger menu"
Agent: _Proceeds to create a menu that slides in from the right with a dark overlay_
Result: User wanted it to slide from the left with no overlay - now you must redo everything

**Good approach (saves time):**
User: "Add a hamburger menu"
Agent: "Before I implement the hamburger menu, I need to clarify a few details:

- Should it slide in from the left, right, or top?
- Do you want an overlay/backdrop when it's open?
- Should it push content or overlay on top?
- What should trigger it to close (click outside, close button, both)?
- Any specific styling requirements (colors, animations, dimensions)?"

**The lesson:** Even common UI patterns have many implementation variations. Making assumptions and building the wrong thing wastes significantly more time than asking 3-5 clarifying questions upfront. If you're not 95% certain about the specifics, ask first.

### Common best practices

- Write clean, readable code with clear variable names
- Follow existing code style and patterns in the project
- Add comments only when code intent is not obvious
- Write error messages that help debug issues
- Validate inputs and handle edge cases
- Use existing utilities and helpers before creating new ones
- Keep functions small and focused on single responsibility
- Avoid premature optimization
- Test changes before considering them complete

## Git practices

**IMPORTANT: Never create commits unless the user explicitly asks you to commit. Making code changes does not give permission to commit them.**

### Pre-commit checklist

Before creating any commit:

1. Run `git status` and `git diff`
2. Read all modified files using file reading tools
3. Verify changes match your intent
4. Write commit message following rules below

The filesystem is the source of truth, not chat history.

### Verification steps

Run these commands:

```bash
git status
git diff
```

Then read all modified files with file reading tools:

- Verify content matches intended changes
- Check for accidental or incomplete modifications
- Check for unrelated changes

### Commit message format

```
type: subject under 50 chars

- Bullet point describing what changed
- Another bullet point if multiple changes
- Use dash and space (- ) for bullets
- Describe actual changes, not file operations
- Keep bullets concise and focused
```

### Commit message checklist

- [ ] Type: `feat` `fix` `docs` `style` `refactor` `perf` `test` `chore` `ci` `build`
- [ ] Subject under 50 characters
- [ ] Lowercase after colon
- [ ] Imperative mood (add, fix, change)
- [ ] No period at end of subject
- [ ] Body included (always required)
- [ ] Body describes what changed, not which files changed
- [ ] Focus on primary change
- [ ] No AI attribution

### Type selection

Use the type that matches the primary change:

- `feat:` new feature or functionality
- `fix:` bug fix
- `docs:` documentation only
- `style:` formatting only
- `refactor:` code restructuring
- `perf:` performance improvement
- `test:` tests
- `chore:` maintenance
- `ci:` CI/CD
- `build:` build system

If you add a feature and update docs, use `feat:` not `docs:`.

### Body rules

Describe what functionality changed, not file operations:

- Bad: "Add auth.js file", "Update user controller"
- Good: "Implement JWT token generation", "Add password validation"

Never include:

- "Generated with Claude Code"
- "Co-Authored-By: Claude"
- Any AI attribution

### Commit examples

```
refactor: adjust cover image layout in single view

- Move title and meta back before cover image
- Restore standard padding-top to site-main
- Reduce image bleed from 130% to 120% width
- Image now bleeds 10% on each side instead of 15%
- Viewport breakpoint adjusted to 1152px (960px * 1.2)
```

```
build: add makefile for docker-based builds

- Add Makefile with BUILD_ENVIRONMENT and BUILD_DESTINATION variables
- Use official Hugo Docker image for builds
- Update GitHub Actions workflow to use make build
- Remove Hugo CLI installation from CI workflow
```

```
fix: prevent double-click form submission

- Add disabled state during form submission
- Prevent duplicate requests on multiple clicks
```

### Forbidden commands

Never use `git reset --hard`. It destroys uncommitted changes permanently with no recovery.

Safe alternatives:

- Discard file: `git restore <file>`
- Unstage: `git restore --staged <file>`
- View previous state: `git diff` or `git show`

If user requests hard reset, warn about data loss and suggest alternatives first.

### Workflow example

```bash
git status
git diff
# Read: src/auth.js, src/routes.js, README.md
# Verify changes match intent

git commit -m "feat: add jwt authentication system

Implement JWT-based authentication with login,
registration, and token refresh endpoints."
```

## Template structure rules

- Let the base layout declare the HTML skeleton with semantic landmarks (`<header>`, `<main>`, `<footer>`) and wrap page content in a shared container utility for consistent width and padding.
- Break views into focused Hugo partials, document their expected inputs, and pass data explicitly (e.g., with `dict`) instead of relying on globals.
- Default to semantic markup plus accessibility helpersâ€”label navigation, expose machine-readable metadata (like `<time datetime>`), provide alt text, and use safe link attributes for external targets.
- Centralize tokens for color, spacing, typography, and motion in a dedicated Sass config file; import component-specific SCSS partials into the main bundle.
- Preserve the SCSS file organization by keeping each partial scoped to a single UI area and using section banners to outline intent.
- Feed CSS and JS through Hugo Pipes, compiling in dev, then minifying, fingerprinting, and caching asset partials for production builds.
- Reuse layout helpers (container widths, spacing variables) instead of inventing ad-hoc measurements to keep rhythm and alignment uniform.
- Render collections through shared list partials that accept data, perform any needed sorting beforehand, and emit both human- and machine-friendly metadata.
- Keep interactive behavior in the primary JS bundle, guard for missing DOM nodes, and flip classes or icon names to reflect state changes instead of rewriting markup.
- Trim extraneous whitespace in templates with `{{-` / `-}}` so the generated HTML stays tidy.
